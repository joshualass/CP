K-Pints(A,B,C,a,b,c,k):

#create visited array with all nodes set to unvisited
visited = [0 ... A][0 ... B][0 ... C]

q = queue()
q.push([a,b,c])

while(!q.isEmpty()):
    val = q.pop()
    curr_a = val[0]
    curr_b = val[1]
    curr_c = val[2]

    if visited[curr_a][curr_b][curr_c] == 1:
        continue

    visited[curr_a][curr_b][curr_c] = 1

    if curr_a == k or curr_b == k or curr_c == k:
        return yes

    #simulate the pours
    pourAB = min(curr_a,B-curr_b)
    q.push([
        curr_a - pourAB,
        curr_b + pourAB,
        curr_c
    ])

    pourAC = min(curr_a,C-curr_c)
    q.push([
        curr_a - pourAC,
        curr_b,
        curr_c + pourAC
    ])

    pourBA = min(curr_b,A-curr_a)
        q.push([
        curr_a + pourBA,
        curr_b - pourBA,
        curr_c
    ])

    pourBC = min(curr_b,C-curr_c)
    q.push([
        curr_a,
        curr_b - pourBC,
        curr_c + pourBC
    ])

    pourCA = min(curr_c,A-curr_a)
    q.push([
        curr_a + pourCA,
        curr_b,
        curr_c - pourCA
    ])

    pourCB = min(curr_c,B-curr_b)
    q.push([
        curr_a,
        curr_b + pourCB,
        curr_c - pourCB
    ])

return no


Basestation-Placement(x,n,k):

base_station_locations = [] #list of positions of base stations
lo_idx = 1 #stores index of westmost house that doesn't have a base station

while lo_idx != n + 1:
    #place a base station as west to it as possible while still being on the road
    base_station_locations.append(min(x[n],x[lo_idx] + k))
    while lo_idx != n + 1 and base_station_locations[len(base_station_locations)] + k >= x[lo_idx]:
        lo_idx += 1

return base_station_locations

create dp[x][y][z] 3d array with all values set to 0
for(int i = 0; i < n; i++) {
    iterate over all triples j,k,l such that j <= x, k <= y, l <= z, and also in order of increasing sum of j + k + l
        make the three transitions from these states --- sell the current house box x, y, or z
        dp[j-1][k][l] = max(dp[j-1][k][l], dp[j][k][l] + A[i]);
        dp[j][k-1][l] = max(dp[j][k-1][l], dp[j][k][l] + B[i]);
        dp[j][k][l-1] = max(dp[j][k][l-1], dp[j][k][l] + C[i]);

}

return max of all values in dp

recursion approach for luci goosey
create dp[n][x][y][z] yikes bad memory :(
create visited[n][x][y][z]
create parents[n][x][y][z] //1 - parent is from x cookie,2  - parent is from y cookie,3 - parent is from z cookie

call recur(n, 0, 0, 0) //we are working backwards now --- start from final house and 0 of each cookie

recur(int house, int i, int j, int k) {
    visited[house][x][y][z] = 1;
    if(i != x) { //not out of bounds
        if(!visited[house-1][i+1][j][k]) { //not visited
            recur(house-1,i+1,j,k);
        }
        try_val = dp[house-1][i+1][j][k] + A[house - 1]
        if(try_val > dp[house][i][j][k]) {
            dp[house][i][j][k] = try_val
            parents[house][i][j][k] = 1
        }
    }

    repeat this process 2 more times using j,y variables and k,z variables

}